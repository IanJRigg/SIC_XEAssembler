	string line;
	int currIndex, length;
	currIndex = 0;
	length = line.length();

	while(currIndex < lenght &&  line[currIndex] != '.' ){} 		// Loop until a period is found or the line has run out
	if(currIndex == length){ 					// If the newline was found, the line is empty
		label = ""
		opcode = ""
		operand = ""
		comment = ""
		return sLine;					// return the struct
	}
	else{							// if a period was found, take the comment out and put it into its token in the struct
		string temp = substr(currIndex, length - 1);
		comment = temp;
	}
	int count, leadIndex;						// Count signifies which token is currently being looked for
	count = leadIndex = 0;					// Lead index is sent ahead when an alphanumeric character is found
	line = substr(0, --currIndex);
	length = line.length();
	currIndex = 0;
	if(isspace(line[currIndex]))					// If the first character in the line is a space, there is no label, increment count to look for the next tokens
		++count;	
	while(currIndex < length){					// Loop until the end of the string
		if(isalpha(line[currIndex]))				// check if an alphanumeric character has been found
			find_next_whitespace(line, &leadIndex);		// send the leadIndex out to find the end of this token
			switch(count){					
				case(1): opcode = substr(currIndex, leadIndex);	// if count is 1, take the found string and make it the opcode
				case(2): operand = substr(currIndex, leadIndex);	// if count is 2, take the found string and make it the operand
			}
			currIndex = leadIndex;			
			count++;					// change the token being looked for
	}
	
	
	find_next_whitespace(string line, int *index){			// increment the lead index until the next word has been found
		while(!isspace(line[*index++]){}
	}